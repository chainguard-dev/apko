// Code generated by counterfeiter. DO NOT EDIT.
package buildfakes

import (
	fsa "io/fs"
	"sync"

	"chainguard.dev/apko/pkg/build/types"
	"chainguard.dev/apko/pkg/exec"
	"chainguard.dev/apko/pkg/options"
	"chainguard.dev/apko/pkg/s6"
	"github.com/chainguard-dev/go-apk/pkg/apk"
	"github.com/chainguard-dev/go-apk/pkg/fs"
	"github.com/google/go-containerregistry/pkg/name"
	"github.com/sigstore/cosign/v2/pkg/oci"
	"gitlab.alpinelinux.org/alpine/go/repository"
)

type FakeBuildImplementation struct {
	AdditionalTagsStub        func(fs.FullFS, *options.Options) error
	additionalTagsMutex       sync.RWMutex
	additionalTagsArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
	}
	additionalTagsReturns struct {
		result1 error
	}
	additionalTagsReturnsOnCall map[int]struct {
		result1 error
	}
	BuildImageStub        func(*options.Options, *types.ImageConfiguration, *exec.Executor, *s6.Context) (fsa.FS, error)
	buildImageMutex       sync.RWMutex
	buildImageArgsForCall []struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
		arg3 *exec.Executor
		arg4 *s6.Context
	}
	buildImageReturns struct {
		result1 fsa.FS
		result2 error
	}
	buildImageReturnsOnCall map[int]struct {
		result1 fsa.FS
		result2 error
	}
	BuildTarballStub        func(*options.Options, fsa.FS) (string, error)
	buildTarballMutex       sync.RWMutex
	buildTarballArgsForCall []struct {
		arg1 *options.Options
		arg2 fsa.FS
	}
	buildTarballReturns struct {
		result1 string
		result2 error
	}
	buildTarballReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GenerateImageSBOMStub        func(*options.Options, *types.ImageConfiguration, oci.SignedImage) error
	generateImageSBOMMutex       sync.RWMutex
	generateImageSBOMArgsForCall []struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
		arg3 oci.SignedImage
	}
	generateImageSBOMReturns struct {
		result1 error
	}
	generateImageSBOMReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateIndexSBOMStub        func(*options.Options, *types.ImageConfiguration, name.Digest, map[types.Architecture]oci.SignedImage) error
	generateIndexSBOMMutex       sync.RWMutex
	generateIndexSBOMArgsForCall []struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
		arg3 name.Digest
		arg4 map[types.Architecture]oci.SignedImage
	}
	generateIndexSBOMReturns struct {
		result1 error
	}
	generateIndexSBOMReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateOSReleaseStub        func(fs.FullFS, *options.Options, *types.ImageConfiguration) error
	generateOSReleaseMutex       sync.RWMutex
	generateOSReleaseArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}
	generateOSReleaseReturns struct {
		result1 error
	}
	generateOSReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateSBOMStub        func(*options.Options, *types.ImageConfiguration) error
	generateSBOMMutex       sync.RWMutex
	generateSBOMArgsForCall []struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
	}
	generateSBOMReturns struct {
		result1 error
	}
	generateSBOMReturnsOnCall map[int]struct {
		result1 error
	}
	InitializeApkStub        func(fs.FullFS, *options.Options, *types.ImageConfiguration) error
	initializeApkMutex       sync.RWMutex
	initializeApkArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}
	initializeApkReturns struct {
		result1 error
	}
	initializeApkReturnsOnCall map[int]struct {
		result1 error
	}
	InstallBusyboxLinksStub        func(fs.FullFS, *options.Options) error
	installBusyboxLinksMutex       sync.RWMutex
	installBusyboxLinksArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
	}
	installBusyboxLinksReturns struct {
		result1 error
	}
	installBusyboxLinksReturnsOnCall map[int]struct {
		result1 error
	}
	InstallCharDevicesStub        func(fs.FullFS) error
	installCharDevicesMutex       sync.RWMutex
	installCharDevicesArgsForCall []struct {
		arg1 fs.FullFS
	}
	installCharDevicesReturns struct {
		result1 error
	}
	installCharDevicesReturnsOnCall map[int]struct {
		result1 error
	}
	InstallLdconfigLinksStub        func(fs.FullFS) error
	installLdconfigLinksMutex       sync.RWMutex
	installLdconfigLinksArgsForCall []struct {
		arg1 fs.FullFS
	}
	installLdconfigLinksReturns struct {
		result1 error
	}
	installLdconfigLinksReturnsOnCall map[int]struct {
		result1 error
	}
	InstallPackagesStub        func(fs.FullFS, *options.Options, *types.ImageConfiguration) error
	installPackagesMutex       sync.RWMutex
	installPackagesArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}
	installPackagesReturns struct {
		result1 error
	}
	installPackagesReturnsOnCall map[int]struct {
		result1 error
	}
	InstalledPackagesStub        func(fs.FullFS, *options.Options) ([]*apk.InstalledPackage, error)
	installedPackagesMutex       sync.RWMutex
	installedPackagesArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
	}
	installedPackagesReturns struct {
		result1 []*apk.InstalledPackage
		result2 error
	}
	installedPackagesReturnsOnCall map[int]struct {
		result1 []*apk.InstalledPackage
		result2 error
	}
	MutateAccountsStub        func(fs.FullFS, *options.Options, *types.ImageConfiguration) error
	mutateAccountsMutex       sync.RWMutex
	mutateAccountsArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}
	mutateAccountsReturns struct {
		result1 error
	}
	mutateAccountsReturnsOnCall map[int]struct {
		result1 error
	}
	MutatePathsStub        func(fs.FullFS, *options.Options, *types.ImageConfiguration) error
	mutatePathsMutex       sync.RWMutex
	mutatePathsArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}
	mutatePathsReturns struct {
		result1 error
	}
	mutatePathsReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshStub        func(*options.Options) (*s6.Context, *exec.Executor, error)
	refreshMutex       sync.RWMutex
	refreshArgsForCall []struct {
		arg1 *options.Options
	}
	refreshReturns struct {
		result1 *s6.Context
		result2 *exec.Executor
		result3 error
	}
	refreshReturnsOnCall map[int]struct {
		result1 *s6.Context
		result2 *exec.Executor
		result3 error
	}
	ResolvePackagesStub        func(fs.FullFS, *options.Options, *types.ImageConfiguration) ([]*repository.RepositoryPackage, []string, error)
	resolvePackagesMutex       sync.RWMutex
	resolvePackagesArgsForCall []struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}
	resolvePackagesReturns struct {
		result1 []*repository.RepositoryPackage
		result2 []string
		result3 error
	}
	resolvePackagesReturnsOnCall map[int]struct {
		result1 []*repository.RepositoryPackage
		result2 []string
		result3 error
	}
	ValidateImageConfigurationStub        func(*types.ImageConfiguration) error
	validateImageConfigurationMutex       sync.RWMutex
	validateImageConfigurationArgsForCall []struct {
		arg1 *types.ImageConfiguration
	}
	validateImageConfigurationReturns struct {
		result1 error
	}
	validateImageConfigurationReturnsOnCall map[int]struct {
		result1 error
	}
	WriteSupervisionTreeStub        func(*s6.Context, *types.ImageConfiguration) error
	writeSupervisionTreeMutex       sync.RWMutex
	writeSupervisionTreeArgsForCall []struct {
		arg1 *s6.Context
		arg2 *types.ImageConfiguration
	}
	writeSupervisionTreeReturns struct {
		result1 error
	}
	writeSupervisionTreeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBuildImplementation) AdditionalTags(arg1 fs.FullFS, arg2 *options.Options) error {
	fake.additionalTagsMutex.Lock()
	ret, specificReturn := fake.additionalTagsReturnsOnCall[len(fake.additionalTagsArgsForCall)]
	fake.additionalTagsArgsForCall = append(fake.additionalTagsArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
	}{arg1, arg2})
	stub := fake.AdditionalTagsStub
	fakeReturns := fake.additionalTagsReturns
	fake.recordInvocation("AdditionalTags", []interface{}{arg1, arg2})
	fake.additionalTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) AdditionalTagsCallCount() int {
	fake.additionalTagsMutex.RLock()
	defer fake.additionalTagsMutex.RUnlock()
	return len(fake.additionalTagsArgsForCall)
}

func (fake *FakeBuildImplementation) AdditionalTagsCalls(stub func(fs.FullFS, *options.Options) error) {
	fake.additionalTagsMutex.Lock()
	defer fake.additionalTagsMutex.Unlock()
	fake.AdditionalTagsStub = stub
}

func (fake *FakeBuildImplementation) AdditionalTagsArgsForCall(i int) (fs.FullFS, *options.Options) {
	fake.additionalTagsMutex.RLock()
	defer fake.additionalTagsMutex.RUnlock()
	argsForCall := fake.additionalTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuildImplementation) AdditionalTagsReturns(result1 error) {
	fake.additionalTagsMutex.Lock()
	defer fake.additionalTagsMutex.Unlock()
	fake.AdditionalTagsStub = nil
	fake.additionalTagsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) AdditionalTagsReturnsOnCall(i int, result1 error) {
	fake.additionalTagsMutex.Lock()
	defer fake.additionalTagsMutex.Unlock()
	fake.AdditionalTagsStub = nil
	if fake.additionalTagsReturnsOnCall == nil {
		fake.additionalTagsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.additionalTagsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) BuildImage(arg1 *options.Options, arg2 *types.ImageConfiguration, arg3 *exec.Executor, arg4 *s6.Context) (fsa.FS, error) {
	fake.buildImageMutex.Lock()
	ret, specificReturn := fake.buildImageReturnsOnCall[len(fake.buildImageArgsForCall)]
	fake.buildImageArgsForCall = append(fake.buildImageArgsForCall, struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
		arg3 *exec.Executor
		arg4 *s6.Context
	}{arg1, arg2, arg3, arg4})
	stub := fake.BuildImageStub
	fakeReturns := fake.buildImageReturns
	fake.recordInvocation("BuildImage", []interface{}{arg1, arg2, arg3, arg4})
	fake.buildImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuildImplementation) BuildImageCallCount() int {
	fake.buildImageMutex.RLock()
	defer fake.buildImageMutex.RUnlock()
	return len(fake.buildImageArgsForCall)
}

func (fake *FakeBuildImplementation) BuildImageCalls(stub func(*options.Options, *types.ImageConfiguration, *exec.Executor, *s6.Context) (fsa.FS, error)) {
	fake.buildImageMutex.Lock()
	defer fake.buildImageMutex.Unlock()
	fake.BuildImageStub = stub
}

func (fake *FakeBuildImplementation) BuildImageArgsForCall(i int) (*options.Options, *types.ImageConfiguration, *exec.Executor, *s6.Context) {
	fake.buildImageMutex.RLock()
	defer fake.buildImageMutex.RUnlock()
	argsForCall := fake.buildImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBuildImplementation) BuildImageReturns(result1 fsa.FS, result2 error) {
	fake.buildImageMutex.Lock()
	defer fake.buildImageMutex.Unlock()
	fake.BuildImageStub = nil
	fake.buildImageReturns = struct {
		result1 fsa.FS
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildImplementation) BuildImageReturnsOnCall(i int, result1 fsa.FS, result2 error) {
	fake.buildImageMutex.Lock()
	defer fake.buildImageMutex.Unlock()
	fake.BuildImageStub = nil
	if fake.buildImageReturnsOnCall == nil {
		fake.buildImageReturnsOnCall = make(map[int]struct {
			result1 fsa.FS
			result2 error
		})
	}
	fake.buildImageReturnsOnCall[i] = struct {
		result1 fsa.FS
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildImplementation) BuildTarball(arg1 *options.Options, arg2 fsa.FS) (string, error) {
	fake.buildTarballMutex.Lock()
	ret, specificReturn := fake.buildTarballReturnsOnCall[len(fake.buildTarballArgsForCall)]
	fake.buildTarballArgsForCall = append(fake.buildTarballArgsForCall, struct {
		arg1 *options.Options
		arg2 fsa.FS
	}{arg1, arg2})
	stub := fake.BuildTarballStub
	fakeReturns := fake.buildTarballReturns
	fake.recordInvocation("BuildTarball", []interface{}{arg1, arg2})
	fake.buildTarballMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuildImplementation) BuildTarballCallCount() int {
	fake.buildTarballMutex.RLock()
	defer fake.buildTarballMutex.RUnlock()
	return len(fake.buildTarballArgsForCall)
}

func (fake *FakeBuildImplementation) BuildTarballCalls(stub func(*options.Options, fsa.FS) (string, error)) {
	fake.buildTarballMutex.Lock()
	defer fake.buildTarballMutex.Unlock()
	fake.BuildTarballStub = stub
}

func (fake *FakeBuildImplementation) BuildTarballArgsForCall(i int) (*options.Options, fsa.FS) {
	fake.buildTarballMutex.RLock()
	defer fake.buildTarballMutex.RUnlock()
	argsForCall := fake.buildTarballArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuildImplementation) BuildTarballReturns(result1 string, result2 error) {
	fake.buildTarballMutex.Lock()
	defer fake.buildTarballMutex.Unlock()
	fake.BuildTarballStub = nil
	fake.buildTarballReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildImplementation) BuildTarballReturnsOnCall(i int, result1 string, result2 error) {
	fake.buildTarballMutex.Lock()
	defer fake.buildTarballMutex.Unlock()
	fake.BuildTarballStub = nil
	if fake.buildTarballReturnsOnCall == nil {
		fake.buildTarballReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.buildTarballReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildImplementation) GenerateImageSBOM(arg1 *options.Options, arg2 *types.ImageConfiguration, arg3 oci.SignedImage) error {
	fake.generateImageSBOMMutex.Lock()
	ret, specificReturn := fake.generateImageSBOMReturnsOnCall[len(fake.generateImageSBOMArgsForCall)]
	fake.generateImageSBOMArgsForCall = append(fake.generateImageSBOMArgsForCall, struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
		arg3 oci.SignedImage
	}{arg1, arg2, arg3})
	stub := fake.GenerateImageSBOMStub
	fakeReturns := fake.generateImageSBOMReturns
	fake.recordInvocation("GenerateImageSBOM", []interface{}{arg1, arg2, arg3})
	fake.generateImageSBOMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) GenerateImageSBOMCallCount() int {
	fake.generateImageSBOMMutex.RLock()
	defer fake.generateImageSBOMMutex.RUnlock()
	return len(fake.generateImageSBOMArgsForCall)
}

func (fake *FakeBuildImplementation) GenerateImageSBOMCalls(stub func(*options.Options, *types.ImageConfiguration, oci.SignedImage) error) {
	fake.generateImageSBOMMutex.Lock()
	defer fake.generateImageSBOMMutex.Unlock()
	fake.GenerateImageSBOMStub = stub
}

func (fake *FakeBuildImplementation) GenerateImageSBOMArgsForCall(i int) (*options.Options, *types.ImageConfiguration, oci.SignedImage) {
	fake.generateImageSBOMMutex.RLock()
	defer fake.generateImageSBOMMutex.RUnlock()
	argsForCall := fake.generateImageSBOMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuildImplementation) GenerateImageSBOMReturns(result1 error) {
	fake.generateImageSBOMMutex.Lock()
	defer fake.generateImageSBOMMutex.Unlock()
	fake.GenerateImageSBOMStub = nil
	fake.generateImageSBOMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) GenerateImageSBOMReturnsOnCall(i int, result1 error) {
	fake.generateImageSBOMMutex.Lock()
	defer fake.generateImageSBOMMutex.Unlock()
	fake.GenerateImageSBOMStub = nil
	if fake.generateImageSBOMReturnsOnCall == nil {
		fake.generateImageSBOMReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateImageSBOMReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) GenerateIndexSBOM(arg1 *options.Options, arg2 *types.ImageConfiguration, arg3 name.Digest, arg4 map[types.Architecture]oci.SignedImage) error {
	fake.generateIndexSBOMMutex.Lock()
	ret, specificReturn := fake.generateIndexSBOMReturnsOnCall[len(fake.generateIndexSBOMArgsForCall)]
	fake.generateIndexSBOMArgsForCall = append(fake.generateIndexSBOMArgsForCall, struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
		arg3 name.Digest
		arg4 map[types.Architecture]oci.SignedImage
	}{arg1, arg2, arg3, arg4})
	stub := fake.GenerateIndexSBOMStub
	fakeReturns := fake.generateIndexSBOMReturns
	fake.recordInvocation("GenerateIndexSBOM", []interface{}{arg1, arg2, arg3, arg4})
	fake.generateIndexSBOMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) GenerateIndexSBOMCallCount() int {
	fake.generateIndexSBOMMutex.RLock()
	defer fake.generateIndexSBOMMutex.RUnlock()
	return len(fake.generateIndexSBOMArgsForCall)
}

func (fake *FakeBuildImplementation) GenerateIndexSBOMCalls(stub func(*options.Options, *types.ImageConfiguration, name.Digest, map[types.Architecture]oci.SignedImage) error) {
	fake.generateIndexSBOMMutex.Lock()
	defer fake.generateIndexSBOMMutex.Unlock()
	fake.GenerateIndexSBOMStub = stub
}

func (fake *FakeBuildImplementation) GenerateIndexSBOMArgsForCall(i int) (*options.Options, *types.ImageConfiguration, name.Digest, map[types.Architecture]oci.SignedImage) {
	fake.generateIndexSBOMMutex.RLock()
	defer fake.generateIndexSBOMMutex.RUnlock()
	argsForCall := fake.generateIndexSBOMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBuildImplementation) GenerateIndexSBOMReturns(result1 error) {
	fake.generateIndexSBOMMutex.Lock()
	defer fake.generateIndexSBOMMutex.Unlock()
	fake.GenerateIndexSBOMStub = nil
	fake.generateIndexSBOMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) GenerateIndexSBOMReturnsOnCall(i int, result1 error) {
	fake.generateIndexSBOMMutex.Lock()
	defer fake.generateIndexSBOMMutex.Unlock()
	fake.GenerateIndexSBOMStub = nil
	if fake.generateIndexSBOMReturnsOnCall == nil {
		fake.generateIndexSBOMReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateIndexSBOMReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) GenerateOSRelease(arg1 fs.FullFS, arg2 *options.Options, arg3 *types.ImageConfiguration) error {
	fake.generateOSReleaseMutex.Lock()
	ret, specificReturn := fake.generateOSReleaseReturnsOnCall[len(fake.generateOSReleaseArgsForCall)]
	fake.generateOSReleaseArgsForCall = append(fake.generateOSReleaseArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}{arg1, arg2, arg3})
	stub := fake.GenerateOSReleaseStub
	fakeReturns := fake.generateOSReleaseReturns
	fake.recordInvocation("GenerateOSRelease", []interface{}{arg1, arg2, arg3})
	fake.generateOSReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) GenerateOSReleaseCallCount() int {
	fake.generateOSReleaseMutex.RLock()
	defer fake.generateOSReleaseMutex.RUnlock()
	return len(fake.generateOSReleaseArgsForCall)
}

func (fake *FakeBuildImplementation) GenerateOSReleaseCalls(stub func(fs.FullFS, *options.Options, *types.ImageConfiguration) error) {
	fake.generateOSReleaseMutex.Lock()
	defer fake.generateOSReleaseMutex.Unlock()
	fake.GenerateOSReleaseStub = stub
}

func (fake *FakeBuildImplementation) GenerateOSReleaseArgsForCall(i int) (fs.FullFS, *options.Options, *types.ImageConfiguration) {
	fake.generateOSReleaseMutex.RLock()
	defer fake.generateOSReleaseMutex.RUnlock()
	argsForCall := fake.generateOSReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuildImplementation) GenerateOSReleaseReturns(result1 error) {
	fake.generateOSReleaseMutex.Lock()
	defer fake.generateOSReleaseMutex.Unlock()
	fake.GenerateOSReleaseStub = nil
	fake.generateOSReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) GenerateOSReleaseReturnsOnCall(i int, result1 error) {
	fake.generateOSReleaseMutex.Lock()
	defer fake.generateOSReleaseMutex.Unlock()
	fake.GenerateOSReleaseStub = nil
	if fake.generateOSReleaseReturnsOnCall == nil {
		fake.generateOSReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateOSReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) GenerateSBOM(arg1 *options.Options, arg2 *types.ImageConfiguration) error {
	fake.generateSBOMMutex.Lock()
	ret, specificReturn := fake.generateSBOMReturnsOnCall[len(fake.generateSBOMArgsForCall)]
	fake.generateSBOMArgsForCall = append(fake.generateSBOMArgsForCall, struct {
		arg1 *options.Options
		arg2 *types.ImageConfiguration
	}{arg1, arg2})
	stub := fake.GenerateSBOMStub
	fakeReturns := fake.generateSBOMReturns
	fake.recordInvocation("GenerateSBOM", []interface{}{arg1, arg2})
	fake.generateSBOMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) GenerateSBOMCallCount() int {
	fake.generateSBOMMutex.RLock()
	defer fake.generateSBOMMutex.RUnlock()
	return len(fake.generateSBOMArgsForCall)
}

func (fake *FakeBuildImplementation) GenerateSBOMCalls(stub func(*options.Options, *types.ImageConfiguration) error) {
	fake.generateSBOMMutex.Lock()
	defer fake.generateSBOMMutex.Unlock()
	fake.GenerateSBOMStub = stub
}

func (fake *FakeBuildImplementation) GenerateSBOMArgsForCall(i int) (*options.Options, *types.ImageConfiguration) {
	fake.generateSBOMMutex.RLock()
	defer fake.generateSBOMMutex.RUnlock()
	argsForCall := fake.generateSBOMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuildImplementation) GenerateSBOMReturns(result1 error) {
	fake.generateSBOMMutex.Lock()
	defer fake.generateSBOMMutex.Unlock()
	fake.GenerateSBOMStub = nil
	fake.generateSBOMReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) GenerateSBOMReturnsOnCall(i int, result1 error) {
	fake.generateSBOMMutex.Lock()
	defer fake.generateSBOMMutex.Unlock()
	fake.GenerateSBOMStub = nil
	if fake.generateSBOMReturnsOnCall == nil {
		fake.generateSBOMReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.generateSBOMReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InitializeApk(arg1 fs.FullFS, arg2 *options.Options, arg3 *types.ImageConfiguration) error {
	fake.initializeApkMutex.Lock()
	ret, specificReturn := fake.initializeApkReturnsOnCall[len(fake.initializeApkArgsForCall)]
	fake.initializeApkArgsForCall = append(fake.initializeApkArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}{arg1, arg2, arg3})
	stub := fake.InitializeApkStub
	fakeReturns := fake.initializeApkReturns
	fake.recordInvocation("InitializeApk", []interface{}{arg1, arg2, arg3})
	fake.initializeApkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) InitializeApkCallCount() int {
	fake.initializeApkMutex.RLock()
	defer fake.initializeApkMutex.RUnlock()
	return len(fake.initializeApkArgsForCall)
}

func (fake *FakeBuildImplementation) InitializeApkCalls(stub func(fs.FullFS, *options.Options, *types.ImageConfiguration) error) {
	fake.initializeApkMutex.Lock()
	defer fake.initializeApkMutex.Unlock()
	fake.InitializeApkStub = stub
}

func (fake *FakeBuildImplementation) InitializeApkArgsForCall(i int) (fs.FullFS, *options.Options, *types.ImageConfiguration) {
	fake.initializeApkMutex.RLock()
	defer fake.initializeApkMutex.RUnlock()
	argsForCall := fake.initializeApkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuildImplementation) InitializeApkReturns(result1 error) {
	fake.initializeApkMutex.Lock()
	defer fake.initializeApkMutex.Unlock()
	fake.InitializeApkStub = nil
	fake.initializeApkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InitializeApkReturnsOnCall(i int, result1 error) {
	fake.initializeApkMutex.Lock()
	defer fake.initializeApkMutex.Unlock()
	fake.InitializeApkStub = nil
	if fake.initializeApkReturnsOnCall == nil {
		fake.initializeApkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initializeApkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallBusyboxLinks(arg1 fs.FullFS, arg2 *options.Options) error {
	fake.installBusyboxLinksMutex.Lock()
	ret, specificReturn := fake.installBusyboxLinksReturnsOnCall[len(fake.installBusyboxLinksArgsForCall)]
	fake.installBusyboxLinksArgsForCall = append(fake.installBusyboxLinksArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
	}{arg1, arg2})
	stub := fake.InstallBusyboxLinksStub
	fakeReturns := fake.installBusyboxLinksReturns
	fake.recordInvocation("InstallBusyboxLinks", []interface{}{arg1, arg2})
	fake.installBusyboxLinksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) InstallBusyboxLinksCallCount() int {
	fake.installBusyboxLinksMutex.RLock()
	defer fake.installBusyboxLinksMutex.RUnlock()
	return len(fake.installBusyboxLinksArgsForCall)
}

func (fake *FakeBuildImplementation) InstallBusyboxLinksCalls(stub func(fs.FullFS, *options.Options) error) {
	fake.installBusyboxLinksMutex.Lock()
	defer fake.installBusyboxLinksMutex.Unlock()
	fake.InstallBusyboxLinksStub = stub
}

func (fake *FakeBuildImplementation) InstallBusyboxLinksArgsForCall(i int) (fs.FullFS, *options.Options) {
	fake.installBusyboxLinksMutex.RLock()
	defer fake.installBusyboxLinksMutex.RUnlock()
	argsForCall := fake.installBusyboxLinksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuildImplementation) InstallBusyboxLinksReturns(result1 error) {
	fake.installBusyboxLinksMutex.Lock()
	defer fake.installBusyboxLinksMutex.Unlock()
	fake.InstallBusyboxLinksStub = nil
	fake.installBusyboxLinksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallBusyboxLinksReturnsOnCall(i int, result1 error) {
	fake.installBusyboxLinksMutex.Lock()
	defer fake.installBusyboxLinksMutex.Unlock()
	fake.InstallBusyboxLinksStub = nil
	if fake.installBusyboxLinksReturnsOnCall == nil {
		fake.installBusyboxLinksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installBusyboxLinksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallCharDevices(arg1 fs.FullFS) error {
	fake.installCharDevicesMutex.Lock()
	ret, specificReturn := fake.installCharDevicesReturnsOnCall[len(fake.installCharDevicesArgsForCall)]
	fake.installCharDevicesArgsForCall = append(fake.installCharDevicesArgsForCall, struct {
		arg1 fs.FullFS
	}{arg1})
	stub := fake.InstallCharDevicesStub
	fakeReturns := fake.installCharDevicesReturns
	fake.recordInvocation("InstallCharDevices", []interface{}{arg1})
	fake.installCharDevicesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) InstallCharDevicesCallCount() int {
	fake.installCharDevicesMutex.RLock()
	defer fake.installCharDevicesMutex.RUnlock()
	return len(fake.installCharDevicesArgsForCall)
}

func (fake *FakeBuildImplementation) InstallCharDevicesCalls(stub func(fs.FullFS) error) {
	fake.installCharDevicesMutex.Lock()
	defer fake.installCharDevicesMutex.Unlock()
	fake.InstallCharDevicesStub = stub
}

func (fake *FakeBuildImplementation) InstallCharDevicesArgsForCall(i int) fs.FullFS {
	fake.installCharDevicesMutex.RLock()
	defer fake.installCharDevicesMutex.RUnlock()
	argsForCall := fake.installCharDevicesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuildImplementation) InstallCharDevicesReturns(result1 error) {
	fake.installCharDevicesMutex.Lock()
	defer fake.installCharDevicesMutex.Unlock()
	fake.InstallCharDevicesStub = nil
	fake.installCharDevicesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallCharDevicesReturnsOnCall(i int, result1 error) {
	fake.installCharDevicesMutex.Lock()
	defer fake.installCharDevicesMutex.Unlock()
	fake.InstallCharDevicesStub = nil
	if fake.installCharDevicesReturnsOnCall == nil {
		fake.installCharDevicesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installCharDevicesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallLdconfigLinks(arg1 fs.FullFS) error {
	fake.installLdconfigLinksMutex.Lock()
	ret, specificReturn := fake.installLdconfigLinksReturnsOnCall[len(fake.installLdconfigLinksArgsForCall)]
	fake.installLdconfigLinksArgsForCall = append(fake.installLdconfigLinksArgsForCall, struct {
		arg1 fs.FullFS
	}{arg1})
	stub := fake.InstallLdconfigLinksStub
	fakeReturns := fake.installLdconfigLinksReturns
	fake.recordInvocation("InstallLdconfigLinks", []interface{}{arg1})
	fake.installLdconfigLinksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) InstallLdconfigLinksCallCount() int {
	fake.installLdconfigLinksMutex.RLock()
	defer fake.installLdconfigLinksMutex.RUnlock()
	return len(fake.installLdconfigLinksArgsForCall)
}

func (fake *FakeBuildImplementation) InstallLdconfigLinksCalls(stub func(fs.FullFS) error) {
	fake.installLdconfigLinksMutex.Lock()
	defer fake.installLdconfigLinksMutex.Unlock()
	fake.InstallLdconfigLinksStub = stub
}

func (fake *FakeBuildImplementation) InstallLdconfigLinksArgsForCall(i int) fs.FullFS {
	fake.installLdconfigLinksMutex.RLock()
	defer fake.installLdconfigLinksMutex.RUnlock()
	argsForCall := fake.installLdconfigLinksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuildImplementation) InstallLdconfigLinksReturns(result1 error) {
	fake.installLdconfigLinksMutex.Lock()
	defer fake.installLdconfigLinksMutex.Unlock()
	fake.InstallLdconfigLinksStub = nil
	fake.installLdconfigLinksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallLdconfigLinksReturnsOnCall(i int, result1 error) {
	fake.installLdconfigLinksMutex.Lock()
	defer fake.installLdconfigLinksMutex.Unlock()
	fake.InstallLdconfigLinksStub = nil
	if fake.installLdconfigLinksReturnsOnCall == nil {
		fake.installLdconfigLinksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installLdconfigLinksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallPackages(arg1 fs.FullFS, arg2 *options.Options, arg3 *types.ImageConfiguration) error {
	fake.installPackagesMutex.Lock()
	ret, specificReturn := fake.installPackagesReturnsOnCall[len(fake.installPackagesArgsForCall)]
	fake.installPackagesArgsForCall = append(fake.installPackagesArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}{arg1, arg2, arg3})
	stub := fake.InstallPackagesStub
	fakeReturns := fake.installPackagesReturns
	fake.recordInvocation("InstallPackages", []interface{}{arg1, arg2, arg3})
	fake.installPackagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) InstallPackagesCallCount() int {
	fake.installPackagesMutex.RLock()
	defer fake.installPackagesMutex.RUnlock()
	return len(fake.installPackagesArgsForCall)
}

func (fake *FakeBuildImplementation) InstallPackagesCalls(stub func(fs.FullFS, *options.Options, *types.ImageConfiguration) error) {
	fake.installPackagesMutex.Lock()
	defer fake.installPackagesMutex.Unlock()
	fake.InstallPackagesStub = stub
}

func (fake *FakeBuildImplementation) InstallPackagesArgsForCall(i int) (fs.FullFS, *options.Options, *types.ImageConfiguration) {
	fake.installPackagesMutex.RLock()
	defer fake.installPackagesMutex.RUnlock()
	argsForCall := fake.installPackagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuildImplementation) InstallPackagesReturns(result1 error) {
	fake.installPackagesMutex.Lock()
	defer fake.installPackagesMutex.Unlock()
	fake.InstallPackagesStub = nil
	fake.installPackagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstallPackagesReturnsOnCall(i int, result1 error) {
	fake.installPackagesMutex.Lock()
	defer fake.installPackagesMutex.Unlock()
	fake.InstallPackagesStub = nil
	if fake.installPackagesReturnsOnCall == nil {
		fake.installPackagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installPackagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) InstalledPackages(arg1 fs.FullFS, arg2 *options.Options) ([]*apk.InstalledPackage, error) {
	fake.installedPackagesMutex.Lock()
	ret, specificReturn := fake.installedPackagesReturnsOnCall[len(fake.installedPackagesArgsForCall)]
	fake.installedPackagesArgsForCall = append(fake.installedPackagesArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
	}{arg1, arg2})
	stub := fake.InstalledPackagesStub
	fakeReturns := fake.installedPackagesReturns
	fake.recordInvocation("InstalledPackages", []interface{}{arg1, arg2})
	fake.installedPackagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBuildImplementation) InstalledPackagesCallCount() int {
	fake.installedPackagesMutex.RLock()
	defer fake.installedPackagesMutex.RUnlock()
	return len(fake.installedPackagesArgsForCall)
}

func (fake *FakeBuildImplementation) InstalledPackagesCalls(stub func(fs.FullFS, *options.Options) ([]*apk.InstalledPackage, error)) {
	fake.installedPackagesMutex.Lock()
	defer fake.installedPackagesMutex.Unlock()
	fake.InstalledPackagesStub = stub
}

func (fake *FakeBuildImplementation) InstalledPackagesArgsForCall(i int) (fs.FullFS, *options.Options) {
	fake.installedPackagesMutex.RLock()
	defer fake.installedPackagesMutex.RUnlock()
	argsForCall := fake.installedPackagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuildImplementation) InstalledPackagesReturns(result1 []*apk.InstalledPackage, result2 error) {
	fake.installedPackagesMutex.Lock()
	defer fake.installedPackagesMutex.Unlock()
	fake.InstalledPackagesStub = nil
	fake.installedPackagesReturns = struct {
		result1 []*apk.InstalledPackage
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildImplementation) InstalledPackagesReturnsOnCall(i int, result1 []*apk.InstalledPackage, result2 error) {
	fake.installedPackagesMutex.Lock()
	defer fake.installedPackagesMutex.Unlock()
	fake.InstalledPackagesStub = nil
	if fake.installedPackagesReturnsOnCall == nil {
		fake.installedPackagesReturnsOnCall = make(map[int]struct {
			result1 []*apk.InstalledPackage
			result2 error
		})
	}
	fake.installedPackagesReturnsOnCall[i] = struct {
		result1 []*apk.InstalledPackage
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildImplementation) MutateAccounts(arg1 fs.FullFS, arg2 *options.Options, arg3 *types.ImageConfiguration) error {
	fake.mutateAccountsMutex.Lock()
	ret, specificReturn := fake.mutateAccountsReturnsOnCall[len(fake.mutateAccountsArgsForCall)]
	fake.mutateAccountsArgsForCall = append(fake.mutateAccountsArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}{arg1, arg2, arg3})
	stub := fake.MutateAccountsStub
	fakeReturns := fake.mutateAccountsReturns
	fake.recordInvocation("MutateAccounts", []interface{}{arg1, arg2, arg3})
	fake.mutateAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) MutateAccountsCallCount() int {
	fake.mutateAccountsMutex.RLock()
	defer fake.mutateAccountsMutex.RUnlock()
	return len(fake.mutateAccountsArgsForCall)
}

func (fake *FakeBuildImplementation) MutateAccountsCalls(stub func(fs.FullFS, *options.Options, *types.ImageConfiguration) error) {
	fake.mutateAccountsMutex.Lock()
	defer fake.mutateAccountsMutex.Unlock()
	fake.MutateAccountsStub = stub
}

func (fake *FakeBuildImplementation) MutateAccountsArgsForCall(i int) (fs.FullFS, *options.Options, *types.ImageConfiguration) {
	fake.mutateAccountsMutex.RLock()
	defer fake.mutateAccountsMutex.RUnlock()
	argsForCall := fake.mutateAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuildImplementation) MutateAccountsReturns(result1 error) {
	fake.mutateAccountsMutex.Lock()
	defer fake.mutateAccountsMutex.Unlock()
	fake.MutateAccountsStub = nil
	fake.mutateAccountsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) MutateAccountsReturnsOnCall(i int, result1 error) {
	fake.mutateAccountsMutex.Lock()
	defer fake.mutateAccountsMutex.Unlock()
	fake.MutateAccountsStub = nil
	if fake.mutateAccountsReturnsOnCall == nil {
		fake.mutateAccountsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mutateAccountsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) MutatePaths(arg1 fs.FullFS, arg2 *options.Options, arg3 *types.ImageConfiguration) error {
	fake.mutatePathsMutex.Lock()
	ret, specificReturn := fake.mutatePathsReturnsOnCall[len(fake.mutatePathsArgsForCall)]
	fake.mutatePathsArgsForCall = append(fake.mutatePathsArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}{arg1, arg2, arg3})
	stub := fake.MutatePathsStub
	fakeReturns := fake.mutatePathsReturns
	fake.recordInvocation("MutatePaths", []interface{}{arg1, arg2, arg3})
	fake.mutatePathsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) MutatePathsCallCount() int {
	fake.mutatePathsMutex.RLock()
	defer fake.mutatePathsMutex.RUnlock()
	return len(fake.mutatePathsArgsForCall)
}

func (fake *FakeBuildImplementation) MutatePathsCalls(stub func(fs.FullFS, *options.Options, *types.ImageConfiguration) error) {
	fake.mutatePathsMutex.Lock()
	defer fake.mutatePathsMutex.Unlock()
	fake.MutatePathsStub = stub
}

func (fake *FakeBuildImplementation) MutatePathsArgsForCall(i int) (fs.FullFS, *options.Options, *types.ImageConfiguration) {
	fake.mutatePathsMutex.RLock()
	defer fake.mutatePathsMutex.RUnlock()
	argsForCall := fake.mutatePathsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuildImplementation) MutatePathsReturns(result1 error) {
	fake.mutatePathsMutex.Lock()
	defer fake.mutatePathsMutex.Unlock()
	fake.MutatePathsStub = nil
	fake.mutatePathsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) MutatePathsReturnsOnCall(i int, result1 error) {
	fake.mutatePathsMutex.Lock()
	defer fake.mutatePathsMutex.Unlock()
	fake.MutatePathsStub = nil
	if fake.mutatePathsReturnsOnCall == nil {
		fake.mutatePathsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mutatePathsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) Refresh(arg1 *options.Options) (*s6.Context, *exec.Executor, error) {
	fake.refreshMutex.Lock()
	ret, specificReturn := fake.refreshReturnsOnCall[len(fake.refreshArgsForCall)]
	fake.refreshArgsForCall = append(fake.refreshArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.RefreshStub
	fakeReturns := fake.refreshReturns
	fake.recordInvocation("Refresh", []interface{}{arg1})
	fake.refreshMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuildImplementation) RefreshCallCount() int {
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	return len(fake.refreshArgsForCall)
}

func (fake *FakeBuildImplementation) RefreshCalls(stub func(*options.Options) (*s6.Context, *exec.Executor, error)) {
	fake.refreshMutex.Lock()
	defer fake.refreshMutex.Unlock()
	fake.RefreshStub = stub
}

func (fake *FakeBuildImplementation) RefreshArgsForCall(i int) *options.Options {
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	argsForCall := fake.refreshArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuildImplementation) RefreshReturns(result1 *s6.Context, result2 *exec.Executor, result3 error) {
	fake.refreshMutex.Lock()
	defer fake.refreshMutex.Unlock()
	fake.RefreshStub = nil
	fake.refreshReturns = struct {
		result1 *s6.Context
		result2 *exec.Executor
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildImplementation) RefreshReturnsOnCall(i int, result1 *s6.Context, result2 *exec.Executor, result3 error) {
	fake.refreshMutex.Lock()
	defer fake.refreshMutex.Unlock()
	fake.RefreshStub = nil
	if fake.refreshReturnsOnCall == nil {
		fake.refreshReturnsOnCall = make(map[int]struct {
			result1 *s6.Context
			result2 *exec.Executor
			result3 error
		})
	}
	fake.refreshReturnsOnCall[i] = struct {
		result1 *s6.Context
		result2 *exec.Executor
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildImplementation) ResolvePackages(arg1 fs.FullFS, arg2 *options.Options, arg3 *types.ImageConfiguration) ([]*repository.RepositoryPackage, []string, error) {
	fake.resolvePackagesMutex.Lock()
	ret, specificReturn := fake.resolvePackagesReturnsOnCall[len(fake.resolvePackagesArgsForCall)]
	fake.resolvePackagesArgsForCall = append(fake.resolvePackagesArgsForCall, struct {
		arg1 fs.FullFS
		arg2 *options.Options
		arg3 *types.ImageConfiguration
	}{arg1, arg2, arg3})
	stub := fake.ResolvePackagesStub
	fakeReturns := fake.resolvePackagesReturns
	fake.recordInvocation("ResolvePackages", []interface{}{arg1, arg2, arg3})
	fake.resolvePackagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeBuildImplementation) ResolvePackagesCallCount() int {
	fake.resolvePackagesMutex.RLock()
	defer fake.resolvePackagesMutex.RUnlock()
	return len(fake.resolvePackagesArgsForCall)
}

func (fake *FakeBuildImplementation) ResolvePackagesCalls(stub func(fs.FullFS, *options.Options, *types.ImageConfiguration) ([]*repository.RepositoryPackage, []string, error)) {
	fake.resolvePackagesMutex.Lock()
	defer fake.resolvePackagesMutex.Unlock()
	fake.ResolvePackagesStub = stub
}

func (fake *FakeBuildImplementation) ResolvePackagesArgsForCall(i int) (fs.FullFS, *options.Options, *types.ImageConfiguration) {
	fake.resolvePackagesMutex.RLock()
	defer fake.resolvePackagesMutex.RUnlock()
	argsForCall := fake.resolvePackagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuildImplementation) ResolvePackagesReturns(result1 []*repository.RepositoryPackage, result2 []string, result3 error) {
	fake.resolvePackagesMutex.Lock()
	defer fake.resolvePackagesMutex.Unlock()
	fake.ResolvePackagesStub = nil
	fake.resolvePackagesReturns = struct {
		result1 []*repository.RepositoryPackage
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildImplementation) ResolvePackagesReturnsOnCall(i int, result1 []*repository.RepositoryPackage, result2 []string, result3 error) {
	fake.resolvePackagesMutex.Lock()
	defer fake.resolvePackagesMutex.Unlock()
	fake.ResolvePackagesStub = nil
	if fake.resolvePackagesReturnsOnCall == nil {
		fake.resolvePackagesReturnsOnCall = make(map[int]struct {
			result1 []*repository.RepositoryPackage
			result2 []string
			result3 error
		})
	}
	fake.resolvePackagesReturnsOnCall[i] = struct {
		result1 []*repository.RepositoryPackage
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBuildImplementation) ValidateImageConfiguration(arg1 *types.ImageConfiguration) error {
	fake.validateImageConfigurationMutex.Lock()
	ret, specificReturn := fake.validateImageConfigurationReturnsOnCall[len(fake.validateImageConfigurationArgsForCall)]
	fake.validateImageConfigurationArgsForCall = append(fake.validateImageConfigurationArgsForCall, struct {
		arg1 *types.ImageConfiguration
	}{arg1})
	stub := fake.ValidateImageConfigurationStub
	fakeReturns := fake.validateImageConfigurationReturns
	fake.recordInvocation("ValidateImageConfiguration", []interface{}{arg1})
	fake.validateImageConfigurationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) ValidateImageConfigurationCallCount() int {
	fake.validateImageConfigurationMutex.RLock()
	defer fake.validateImageConfigurationMutex.RUnlock()
	return len(fake.validateImageConfigurationArgsForCall)
}

func (fake *FakeBuildImplementation) ValidateImageConfigurationCalls(stub func(*types.ImageConfiguration) error) {
	fake.validateImageConfigurationMutex.Lock()
	defer fake.validateImageConfigurationMutex.Unlock()
	fake.ValidateImageConfigurationStub = stub
}

func (fake *FakeBuildImplementation) ValidateImageConfigurationArgsForCall(i int) *types.ImageConfiguration {
	fake.validateImageConfigurationMutex.RLock()
	defer fake.validateImageConfigurationMutex.RUnlock()
	argsForCall := fake.validateImageConfigurationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuildImplementation) ValidateImageConfigurationReturns(result1 error) {
	fake.validateImageConfigurationMutex.Lock()
	defer fake.validateImageConfigurationMutex.Unlock()
	fake.ValidateImageConfigurationStub = nil
	fake.validateImageConfigurationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) ValidateImageConfigurationReturnsOnCall(i int, result1 error) {
	fake.validateImageConfigurationMutex.Lock()
	defer fake.validateImageConfigurationMutex.Unlock()
	fake.ValidateImageConfigurationStub = nil
	if fake.validateImageConfigurationReturnsOnCall == nil {
		fake.validateImageConfigurationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateImageConfigurationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) WriteSupervisionTree(arg1 *s6.Context, arg2 *types.ImageConfiguration) error {
	fake.writeSupervisionTreeMutex.Lock()
	ret, specificReturn := fake.writeSupervisionTreeReturnsOnCall[len(fake.writeSupervisionTreeArgsForCall)]
	fake.writeSupervisionTreeArgsForCall = append(fake.writeSupervisionTreeArgsForCall, struct {
		arg1 *s6.Context
		arg2 *types.ImageConfiguration
	}{arg1, arg2})
	stub := fake.WriteSupervisionTreeStub
	fakeReturns := fake.writeSupervisionTreeReturns
	fake.recordInvocation("WriteSupervisionTree", []interface{}{arg1, arg2})
	fake.writeSupervisionTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuildImplementation) WriteSupervisionTreeCallCount() int {
	fake.writeSupervisionTreeMutex.RLock()
	defer fake.writeSupervisionTreeMutex.RUnlock()
	return len(fake.writeSupervisionTreeArgsForCall)
}

func (fake *FakeBuildImplementation) WriteSupervisionTreeCalls(stub func(*s6.Context, *types.ImageConfiguration) error) {
	fake.writeSupervisionTreeMutex.Lock()
	defer fake.writeSupervisionTreeMutex.Unlock()
	fake.WriteSupervisionTreeStub = stub
}

func (fake *FakeBuildImplementation) WriteSupervisionTreeArgsForCall(i int) (*s6.Context, *types.ImageConfiguration) {
	fake.writeSupervisionTreeMutex.RLock()
	defer fake.writeSupervisionTreeMutex.RUnlock()
	argsForCall := fake.writeSupervisionTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuildImplementation) WriteSupervisionTreeReturns(result1 error) {
	fake.writeSupervisionTreeMutex.Lock()
	defer fake.writeSupervisionTreeMutex.Unlock()
	fake.WriteSupervisionTreeStub = nil
	fake.writeSupervisionTreeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) WriteSupervisionTreeReturnsOnCall(i int, result1 error) {
	fake.writeSupervisionTreeMutex.Lock()
	defer fake.writeSupervisionTreeMutex.Unlock()
	fake.WriteSupervisionTreeStub = nil
	if fake.writeSupervisionTreeReturnsOnCall == nil {
		fake.writeSupervisionTreeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeSupervisionTreeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBuildImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.additionalTagsMutex.RLock()
	defer fake.additionalTagsMutex.RUnlock()
	fake.buildImageMutex.RLock()
	defer fake.buildImageMutex.RUnlock()
	fake.buildTarballMutex.RLock()
	defer fake.buildTarballMutex.RUnlock()
	fake.generateImageSBOMMutex.RLock()
	defer fake.generateImageSBOMMutex.RUnlock()
	fake.generateIndexSBOMMutex.RLock()
	defer fake.generateIndexSBOMMutex.RUnlock()
	fake.generateOSReleaseMutex.RLock()
	defer fake.generateOSReleaseMutex.RUnlock()
	fake.generateSBOMMutex.RLock()
	defer fake.generateSBOMMutex.RUnlock()
	fake.initializeApkMutex.RLock()
	defer fake.initializeApkMutex.RUnlock()
	fake.installBusyboxLinksMutex.RLock()
	defer fake.installBusyboxLinksMutex.RUnlock()
	fake.installCharDevicesMutex.RLock()
	defer fake.installCharDevicesMutex.RUnlock()
	fake.installLdconfigLinksMutex.RLock()
	defer fake.installLdconfigLinksMutex.RUnlock()
	fake.installPackagesMutex.RLock()
	defer fake.installPackagesMutex.RUnlock()
	fake.installedPackagesMutex.RLock()
	defer fake.installedPackagesMutex.RUnlock()
	fake.mutateAccountsMutex.RLock()
	defer fake.mutateAccountsMutex.RUnlock()
	fake.mutatePathsMutex.RLock()
	defer fake.mutatePathsMutex.RUnlock()
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	fake.resolvePackagesMutex.RLock()
	defer fake.resolvePackagesMutex.RUnlock()
	fake.validateImageConfigurationMutex.RLock()
	defer fake.validateImageConfigurationMutex.RUnlock()
	fake.writeSupervisionTreeMutex.RLock()
	defer fake.writeSupervisionTreeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBuildImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
