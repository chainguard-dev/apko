package ldsocache

import (
	"os"
	"testing"

	"github.com/stretchr/testify/require"
)

func Test_LoadCacheFile(t *testing.T) {
	cacheFile, err := LoadCacheFile("testdata/ld.so.cache")
	require.NoError(t, err)
	require.Equalf(t, uint32(65), cacheFile.Header.NumLibs, "there should be 65 libraries in this cache file")
	require.Equalf(t, uint32(1421), cacheFile.Header.StrTableSize, "the string table should be 1421 bytes long")
	require.Equalf(t, 1, len(cacheFile.Extensions), "there must be 1 extension")

	ext := cacheFile.Extensions[0]
	require.Equalf(t, uint32(0), ext.Header.Tag, "extension data must be tag 0 (generator)")
	require.Equalf(t, []byte("ldconfig (GNU libc) stable release version 2.36"), ext.Data, "must be generated by glibc 2.36")
}

func Test_WriteCacheFile(t *testing.T) {
	cacheFile, err := LoadCacheFile("testdata/ld.so.cache")
	require.NoError(t, err)
	out, err := os.CreateTemp(t.TempDir(), "ld.so.cache-new")
	require.NoError(t, err)
	err = cacheFile.Write(out)
	require.NoError(t, err)
}

func Test_ParseLibFilename(t *testing.T) {
	name, ver, err := ParseLibFilename("libfoo.so.1")
	require.NoError(t, err)
	require.Equal(t, name, "libfoo")
	require.Equal(t, ver, "1")
}

func Test_ParseLibFilename_Versioned_DotOne(t *testing.T) {
	name, ver, err := ParseLibFilename("libfoo.so.1")
	require.NoError(t, err)
	require.Equal(t, name, "libfoo")
	require.Equal(t, ver, "1")
}

func Test_ParseLibFilename_Versioned_DotOneDotTwo(t *testing.T) {
	name, ver, err := ParseLibFilename("libfoo.so.1.2")
	require.NoError(t, err)
	require.Equal(t, name, "libfoo")
	require.Equal(t, ver, "1.2")
}

func Test_ParseLibFilename_Versioned_SoSo_DotOne(t *testing.T) {
	name, ver, err := ParseLibFilename("libso.so.1")
	require.NoError(t, err)
	require.Equal(t, name, "libso")
	require.Equal(t, ver, "1")
}

func Test_ParseLibFilename_Unversioned_SoSo(t *testing.T) {
	name, ver, err := ParseLibFilename("libso.so")
	require.NoError(t, err)
	require.Equal(t, name, "libso")
	require.Equal(t, ver, "")
}

func Test_ParseLibFilename_Unversioned_SoDotSoDotSo(t *testing.T) {
	name, ver, err := ParseLibFilename("libso.so.so")
	require.NoError(t, err)
	require.Equal(t, name, "libso.so")
	require.Equal(t, ver, "")
}

func Test_ParseLibFilename_Versioned_SoDotSoDotSoVer(t *testing.T) {
	name, ver, err := ParseLibFilename("libso.so.so.7")
	require.NoError(t, err)
	require.Equal(t, name, "libso.so")
	require.Equal(t, ver, "7")
}

func Test_ParseLibFilename_HangingSo(t *testing.T) {
	// Unclear if this should be an error
	name, ver, err := ParseLibFilename("libfoo.so.")
	require.NoError(t, err)
	require.Equal(t, name, "libfoo")
	require.Equal(t, ver, "")
}

func Test_ParseLibFilename_Versioned_NoName(t *testing.T) {
	// Unclear if this should be an error
	name, ver, err := ParseLibFilename("lib.so")
	require.NoError(t, err)
	require.Equal(t, name, "lib")
	require.Equal(t, ver, "")
}

func Test_ParseLibFilename_NoLibPrefix(t *testing.T) {
	_, _, err := ParseLibFilename("foo.so.1")
	require.Error(t, err)
}

func Test_ParseLibFilename_NoSo(t *testing.T) {
	_, _, err := ParseLibFilename("libfoo.no.1")
	require.Error(t, err)
}

func Test_ParseLDSOConf_Simple(t *testing.T) {
	fsys := os.DirFS("testdata")
	dirs, err := ParseLDSOConf(fsys, "ld.so.conf.simple")
	require.NoError(t, err)
	require.Equal(t, 1, len(dirs))
	require.Equal(t, "/lib", dirs[0])
}

func Test_ParseLDSOConf_Glob(t *testing.T) {
	fsys := os.DirFS("testdata")
	dirs, err := ParseLDSOConf(fsys, "ld.so.conf.glob")
	require.NoError(t, err)
	require.Contains(t, dirs, "/a/libs")
	require.Contains(t, dirs, "/b/libs")
}

func Test_GenerateCacheFile(t *testing.T) {
	// This uses the host system, uncomment to run tests on your machine.
	t.Skip()

	libdirs := []string{"/lib"}
	root := os.DirFS("/")
	dirs, err := ParseLDSOConf(root, "etc/ld.so.conf")
	require.NoError(t, err)
	libdirs = append(libdirs, dirs...)
	cacheFile, err := BuildCacheFileForDirs(root, libdirs)
	require.NoError(t, err)
	lsc, err := os.Create("testdata/ld.so.cache-generated")
	require.NoError(t, err)
	err = cacheFile.Write(lsc)
	require.NoError(t, err)
}
